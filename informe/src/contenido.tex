%empezar el tp aca
\section{DiseÒo}

Para organizar este trabajo, lo primero que hicimos fue decidir cÛmo querÌamos analizar el texto entrante para poder dilucidar si contenÌa o no malas palabras. 

Previo al diseño final estabamos casi convencidos de que el diseño debia consistir de un organizador, encargado de enviar el texto a los filtros para luego volver a recibirlo "limpio". Luego este enviaría a analizar el texto fijandose si pertenecía al diccionario de palabras prohibidas obteniendo finalmente el resultado que sería el que mostraba por pantalla.
A primera instancia notamos que de la forma en que estaba implementado, iba a traer resultados incorrectos ya que la ausencia de un diccionario de excepciones no permitía el ingreso de palabras válidas solo por el hecho de tener una palabra prohibida en el medio, tal como el caso de "computadora". Luego del analisis llegamos a la conclusión que este diseño, si bien cumplía con lo solicitado, se restringia a centralizar todo en el objeto organizador y esto no era realmente necesario, por lo que optamos por virar a un nuevo diseño, que es el finalmente presentado, logrando de esta forma una manera mas fácil de intercalar etapas en la cadena de proceso del texto de entrada y no tener la necesidad de modificar la construcción de la serie de filtros que se aplican.

Luego de debatir en el grupo, llegamos a la conclusiÛn que el diseÒo de nuestra aplicaciÛn iba a constituirse por un conjunto de filtros, un diccionario de palabras prohibidas y uno de excepciones (este originalmente no estaba en los planes, pero luego nos dimos cuenta que era necesario si querÌamos lograr que palabras como "computadora" no fueran detectadas como insultos).
Seg˙n nuestro diseÒo, al ingresarse un texto, Este llega al objeto controlador, el cual tiene una secuencia de etapas (que son nombres de clase, de las que se crear· una instancia) por las que va a ser pasado el texto. Nuestra idea es que en el controlador se configure la secuencia de filtros que se van a aplicar, el orden en que se va a hacer, y los diccionarios sobre los que se va a consultar. Por lo tanto, al definirse una secuencia de etapas, cada una de ellas va a procesar el texto de la manera que haya sido configurado para hacerlo, y luego va a enviar el texto procesado al siguiente elemento de la secuencia. Las etapas son diferentes objetos polimÛrficos respecto de dos mensajes, {textit}do{/textit} y {textit}prox{/textit}. En el metodo {textit}do{/textit}, cada etapa har· el proceso que le corresponda, y llamar· al mÈtodo prox que est· definido en la clase abstracta Etapa, que remueve el primer elemento de la secuencia, crea una nueva instancia del mismo y a ese elemento le manda el mensaje{textit}do{/textit}.

Nuestra idea es que al principio de la secuencia se definan filtros, cuya funciÛn es "limpiar" el texto para facilitar la detecciÛn de malas palabras. Por ejemplo, una de las categorÌas que nos comprometimos a detectar es el reemplazo de letras por sÌmbolos y/o n˙meros. Entonces, el filtro para n˙meros/sÌmbolos define una conversiÛn de sÌmbolos a letras (por ejemplo, el n˙mero 5 puede representar la letra S, la @ la A, etc), y al aplicarlo al texto reemplaza esos sÌmbolos por las letras que representan, de manera tal que al recibir el input "t@r@d0" va a convertirlo en "tarado"

Luego de aplicar todos los filtros, el texto se pasa al diccionario de excepciones, que son las que contienen una mala palabra en su interior pero que no son insultos, como computadora, con las excepciones se busca que se quiten estas excepciones del texto antes de buscar malas palabras. Una vez hecho esto, el texto est· listo para ser chequeado por palabras prohibidas; en esta etapa, se define un diccionario de tÈrminos prohibidos y se busca si el texto contiene alguno de ellos, en caso de hacerlo, se vuelve al controlador con un resultado diciendo que no se aceptÛ el texto, y con un resultado de que sÌ se aceptÛ en caso contrario. 

Es importante remarcar que la manera que tenemos de buscar los términos prohibidos hace que soportemos algunas categorÌas para las cuales no hay filtros, por ejemplo, para la categorÌa pegado, el texto "sostarado" contiene la palabra "tarado", la cual est· prohibida por lo tanto, el chequeo va a dar inv·lido a˙n cuando no se haya definido filtro para separar la palabra

Finalmente nos terminamos de convencer de optar por este diseño cuando notamos que a diferencia del diseño anterior, el diseño actual permite agregar múltiples etapas, independientemente de su tipo, es decir, sin importar si son filtros o diccionarios, teniendo como única restriccion que estan sean polimórficas con respecto de Etapa. Esto nos va a permitir agregar nuevas funcionalidades cuando sean requeridan sin tener que cambiar el codigo ya existente, permitiendo tambien así agregar nuevas categorias fácilmente

\section{Retrospectiva}

Durante este sprint nos encontramos con múltiples barreras que nos llevaron a no poder cumplir estrictamente el dashboard planeado, respetando los tiempos que estimamos para el mismo.

Con el afán de obtener los mejores resultados posibles para presentar un sistema correcto, nos vimos involucrados en múltiples discusiones acerca del diseño que debiamos utilizar, que nos quitaron una gran parte del sprint ya que no lograbamos ponernos de acuerdo
Esta indecisión nos provocó un retraso importante en lo que correspondía al armado del sistema, provocando que ante la necesidad de cumplir con lo pactado no logramos llevar una correcta exhibición de las tareas que ibamos realizando en nuestro sistema de seguimiento.

En una próxima iteración creemos que deberíamos mejorar en cuanto al tiempo dedicado para tomar decisiones (Tambien demoramos mucho en poder elegir el lenguaje de programación a utilizar) y en una correcta distribución de tareas, dividiendo estas logrando explotar en mayor medidas las habilidades de cada integrante del equipo
